'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

var isDev = process.env.NODE_ENV !== "production";
var NO_PROVIDER = "_NP_";

function createUseContext(context) {
  return function () {
    var value = React.useContext(context);

    if (isDev && value === NO_PROVIDER) {
      // eslint-disable-next-line no-console
      console.warn("[constate] Component not wrapped within a Provider.");
    }

    return value;
  };
}

function warnAboutObjectUsage() {
  if (isDev) {
    // eslint-disable-next-line no-console
    console.warn("[constate] Getting { Context, Provider } from constate is deprecated. " + "Please, use the tuple format instead. " + "See instructions on https://github.com/diegohaz/constate/pull/101");
  }
}

function constate(useValue) {
  for (var _len = arguments.length, splitValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    splitValues[_key - 1] = arguments[_key];
  }

  var Context = React.createContext(NO_PROVIDER);

  var Provider = function Provider(props) {
    var value = useValue(props);
    return React.createElement(Context.Provider, {
      value: value
    }, props.children);
  };

  if (isDev && useValue.name) {
    Context.displayName = useValue.name + ".Context";
    Provider.displayName = useValue.name + ".Provider";
  } // const useCounterContext = constate(...)


  var useContext = function useContext() {
    if (isDev) {
      // eslint-disable-next-line no-console
      console.warn("[constate] Using the return value of constate as a hook is deprecated. " + "Please, use the tuple format instead. " + "See instructions on https://github.com/diegohaz/constate/pull/101");
    }

    return createUseContext(Context)();
  }; // const { Context, Provider } = constate(...)


  Object.defineProperties(useContext, {
    Context: {
      get: function get() {
        warnAboutObjectUsage();
        return Context;
      }
    },
    Provider: {
      get: function get() {
        warnAboutObjectUsage();
        return Provider;
      }
    }
  });
  var tuple = [];

  if (!splitValues.length) {
    // const [Provider, useCounterContext] = constate(...);
    tuple.push(Provider, createUseContext(Context));
  } else {
    var contexts = [];

    var SplitProvider = function SplitProvider(props) {
      var value = useValue(props);
      var children = props.children;

      for (var i = 0; i < contexts.length; i += 1) {
        var context = contexts[i]; // splitValue may be a hook, but it won't change between re-renders

        var splitValue = splitValues[i];
        children = React.createElement(context.Provider, {
          value: splitValue(value)
        }, children);
      }

      return children;
    };

    if (isDev && useValue.name) {
      SplitProvider.displayName = useValue.name + ".Provider";
    } // const [Provider, useCount, useIncrement] = constate(...);


    tuple.push(SplitProvider);

    for (var i = 0; i < splitValues.length; i += 1) {
      var context = React.createContext(NO_PROVIDER);
      contexts.push(context);
      tuple.push(createUseContext(context));
    }
  }

  for (var _i = 0; _i < tuple.length; _i += 1) {
    useContext[_i] = tuple[_i];
  }

  if (typeof Symbol === "function" && Symbol.iterator) {
    useContext[Symbol.iterator] =
    /* istanbul ignore next */
    function () {
      return tuple[Symbol.iterator]();
    };
  }

  return useContext;
}

exports.default = constate;
